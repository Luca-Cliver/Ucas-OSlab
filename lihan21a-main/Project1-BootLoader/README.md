# Project 1:Bootloader
## 添加代码  
### 1.首先在bootblock.S中添加代码,打印出"It's a bootloader...\n\r"，然后调用函数bios_sdread把kernel中的代码从镜像文件读到主存中，加载的大小和偏移要通过bootblock.S取出作为参数传入。  
### 2.完善head.S文件，这部分是kernel最开始的部分，需要添加添加清空bss段，再为kernel提供c语言环境，在跳转到main执行，需要注意的事bss起始和终止位置需要到riscv.lds中去找。
### 3.crt0.S中添加代码为用户程序清空bss段，然后为其提供C语言环境，开辟栈帧，跳转到对应程序的main函数中，等执行完后再回收栈帧，跳回kernel。
### 4.main.c中，要跳转到对应用户程序的位置，如果是task3，只需要用程序的id即可，如果是之后的任务，就要先定义init_task_info函数，利用指针得到提前写入主存的task_info地址，调用bios_sdread把其读取到主存，然后再赋给main.c中的tasks。得到之后，调用load_task_img函数加载用户程序到内存，得到入口地址，再跳转到这个地址，方法有很多种，我选择了用内联汇编的方式，看起来比较直接。
### 5.在loader.c中添加的代码是对load_task_img函数的定义，通过taskinfo给出的信息，将用户程序加载到内存中，然后返回入口地址。同时要用memcpy函数把用户程序平移到入口地址。
### 6.createimage.c中添加的代码比较多，在task5之前需要先定义task_info，通过程序头提供的信息，把用户程序的大小，偏移，入口地址等放到task_info里面，在task3里由于不是密集排列，要进行padding。还要在write_img_info函数中把在main函数中需要用到的程序的信息写入到镜像文件，地址除了os_size可以自定义。
### 7.task5里在createimage.c这个文件添加了一个新函数write_kernel，任务是当准备写入kernel时，调用给出的函数将其压缩，压缩前后的大小在我的设计中需要记录并写入镜像文件中。这个过程需要更改一些先前给出的设定。
### 8.创建一个新文件decompress.c，用于解压先前压缩的kernel，我选择将其与kernel的地位等价，先把这个程序写到镜像文件里，入口地址大小和kernel一样写入镜像。在bootblock里不再读取kernel而是读取这个函数，然后跳转到这个程序，在这个程序里读取kernel并解压，然后跳转到kernel的main函数。
### 9.在makefile中重新更改编译命令，加上编译decompress.c的命令，并给createimage.处增加头文件。

## 实验过程
### 本次实验虽然是这个课程中比较简单实验，但对我来说还是有不小的挑战。task1还比较简单，到task2就需要搞清楚代码的框架，刚开始不理解镜像文件与要实现的内容的关系，与助教和同学交流，再反复读课件才理解。
### task3在弄明白了框架之后就简单了一些，刚开始不知道怎么在crt0.S中跳回内核，经学长点拨知道了可以设置栈帧存储返回地址，对这一连接方式有了新的认知。印象很深的bug是task4时，清楚bss段时我用了s0，s1两个寄存器来临时存储起始终止位置，导致程序出现了非常奇怪的bug，因为s0,s1是系统的寄存器，需要保留，这也是之前写汇编的坏习惯导致的。
### task4中就遇到了一些麻烦，首先是task_info中定义的内容该怎么获取，写到镜像文件中有该怎样读取到main.c中的tasks，最后决定直接在main.c中声明一个指向这个结构的指针，直接将读过来的内容赋值。还有是在main函数中通过名字来转化成用户程序的id，这一部分思路借鉴了史文轩学长的设计，这种设计更方便添加一些人性化的功能，我认为比较巧妙。
### task5是这次实验的重头戏，在各个位置都遇到了不小的困难，压缩函数里需要把压缩前后的大小写入镜像，同时要保证压缩前后初始地址不变。解压函数同样也要保证地址搬对，期间遇到了一些小bug，但好在不致命，花费时间最多的是对makefile的编写，编译新的文件，给createimage.c增加头文件，最后是在同学的帮助下成功编译出来并运行了。

## 心得体会
### 这次实验算是我第一次接触大体量的编程，虽然实现的功能很简单，但也花费了一些时间，但做下来感觉对这个代码的架构清晰多了，从刚开始无从下手到现在可以动手去debug，尽管还不太熟练，但可以感觉到有一些进步。同时也见到了一些新的bug，丰富了我debug的经验。受益良多！